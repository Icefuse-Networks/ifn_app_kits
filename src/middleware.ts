/**
 * Middleware - Route Protection
 *
 * PUBLIC ROUTES:
 * - Landing page (/) and static assets are publicly accessible
 * - Auth routes (/api/auth/*) for NextAuth callbacks
 *
 * PROTECTED ROUTES:
 * - All other routes require authentication
 * - Admin permission checks are done via /api/admin/verify-access
 *   (NOT in middleware - matches PayNow pattern)
 */

import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { getToken } from 'next-auth/jwt'
import { debugLog } from '@icefuse/auth/config'

// Routes that don't require authentication (prefix matching)
// Note: API routes handle their own auth via authenticateWithScope (Bearer tokens)
// or requireSession, so they bypass session-only middleware checks
const PUBLIC_PATH_PREFIXES = [
  '/auth',
  '/api/auth',
  '/api/public',
  '/api/kits',
  '/api/analytics',
  '/api/telemetry',
  '/api/servers',
  '/api/identifiers',
  '/api/redirect',
  '/api/items',
  '/api/skins',
  '/api/events',
  '/api/lootmanager/download',
  '/api/bases/download',
  '/api/bases/stats',
  '/api/rust-servers',
  '/api/announcements',
  '/api/giveaway',
  '/api/feedback',
  '/api/shop/download',
  '/kits',
  '/_next',
  '/logos',
]

// Exact paths that don't require authentication
const PUBLIC_EXACT_PATHS = [
  '/',
  '/favicon.ico',
  '/logo.png',
  '/leaderboards',
]

// Production domain patterns for hostname detection
const PRODUCTION_DOMAINS = ['icefuse.com', 'ifn.gg']

// App name for cookie naming (must match @icefuse/auth config)
const APP_NAME = process.env.ICEFUSE_APP_NAME!

/**
 * Check if hostname is a production domain
 */
function isProductionHostname(hostname: string): boolean {
  const normalizedHost = hostname.toLowerCase()
  return PRODUCTION_DOMAINS.some(
    domain => normalizedHost === domain || normalizedHost.endsWith(`.${domain}`)
  )
}

/**
 * Get cookie name for session token
 * Must match the cookie names generated by @icefuse/auth package
 */
function getSessionCookieName(isProd: boolean): string {
  const prefix = isProd ? '__Secure-' : ''
  return `${prefix}icefuse-${APP_NAME}.session-token`
}

/**
 * Get the real hostname from request (handles reverse proxy)
 */
function getRealHostname(request: NextRequest): string {
  // Check X-Forwarded-Host first (set by reverse proxy like Traefik)
  const forwardedHost = request.headers.get('x-forwarded-host')
  if (forwardedHost) {
    // May contain multiple hosts, take the first one
    return forwardedHost.split(',')[0].trim().toLowerCase()
  }

  // Check Host header
  const hostHeader = request.headers.get('host')
  if (hostHeader) {
    // Remove port if present
    return hostHeader.split(':')[0].toLowerCase()
  }

  // Fallback to URL hostname
  return request.nextUrl.hostname.toLowerCase()
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  const hostname = getRealHostname(request)

  // Allow public paths (exact matches or prefix matches)
  if (
    PUBLIC_EXACT_PATHS.includes(pathname) ||
    PUBLIC_PATH_PREFIXES.some(prefix => pathname.startsWith(prefix))
  ) {
    return NextResponse.next()
  }

  const isProd = isProductionHostname(hostname)
  const cookieName = getSessionCookieName(isProd)

  debugLog('Middleware', `${pathname}`, {
    hostname,
    isProd,
    cookieName,
  })

  // SECURITY: Secret from env vars only (no hardcoded values)
  const token = await getToken({
    req: request,
    secret: process.env.NEXTAUTH_SECRET!,
    secureCookie: isProd,
    cookieName,
  })

  // If no token, redirect to signin page which initiates OIDC flow
  if (!token) {
    debugLog('Middleware', `No token found for ${pathname}, redirecting to signin`)

    // RSC/prefetch requests use fetch() which can't follow cross-origin
    // redirects (CORS). Return 204 so Next.js falls back to browser navigation.
    if (request.headers.get('rsc') === '1' || request.headers.get('next-router-prefetch') === '1') {
      return new NextResponse(null, { status: 204 })
    }

    // Redirect to our signin page which calls signIn('icefuse')
    const signinUrl = new URL('/auth/signin', request.url)
    signinUrl.searchParams.set('callbackUrl', pathname)
    return NextResponse.redirect(signinUrl)
  }

  debugLog('Middleware', `Token found for ${pathname}`, {
    sub: token.sub,
    error: (token as Record<string, unknown>).error || 'none',
  })

  // SECURITY: Admin-only routes require isAdmin or isRoot claim from OIDC
  const adminOnlyPrefixes = ['/dashboard', '/api/admin', '/legacy']
  const isAdminRoute = adminOnlyPrefixes.some(prefix => pathname.startsWith(prefix))

  if (isAdminRoute) {
    const user = (token as Record<string, unknown>).user as Record<string, unknown> | undefined
    const hasAdmin = Boolean(user?.isAdmin || user?.isRoot)

    if (!hasAdmin) {
      debugLog('Middleware', `Admin access denied for ${pathname} (isAdmin=${user?.isAdmin}, isRoot=${user?.isRoot})`)

      if (pathname.startsWith('/api/')) {
        return NextResponse.json({ error: 'Admin access required' }, { status: 403 })
      }

      return NextResponse.redirect(new URL('/?error=AccessDenied', request.url))
    }
  }

  return NextResponse.next()
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
